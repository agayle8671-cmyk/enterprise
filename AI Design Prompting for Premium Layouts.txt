Engineering the Raycast Aesthetic: A Definitive Technical Analysis of High-Fidelity Typewriter Animations and Modern Design Systems
1. The Paradigm Shift to Productivity Luxury
The evolution of web interface design has entered a distinct phase in the mid-2020s, characterized by a move away from the flat, playful aesthetics of the previous decade toward a style often termed "Productivity Luxury" or the "Linear/Raycast Aesthetic." This design language is defined by a rigorous adherence to utility, speed, and deep immersion, manifested through sophisticated dark modes, translucent glassmorphism, and, critically, kinetic typography. At the heart of this aesthetic lies the typewriter text effect—a dynamic, looping animation that simulates user input with mechanical precision. While historically used as a decorative element, in the context of tools like Raycast and Linear, the typewriter effect transcends ornamentation to become a core narrative device. It demonstrates the software’s capability—parsing commands, searching databases, or executing scripts—without requiring the user to disengage from the interface to watch a video tutorial.
Implementing a production-grade typewriter effect that mimics the Raycast user experience is not a trivial frontend task. It requires a convergence of advanced React state management, precise CSS layout engineering, and a deep understanding of motion design principles. It is insufficient to merely cycle through an array of strings; the animation must account for human-like typing variance, "smart" backspacing that recognizes common prefixes, and layout stability to prevent Cumulative Layout Shift (CLS). Furthermore, the effect must exist within a design system that supports high-contrast dark modes and seamless accessibility.
This report provides an exhaustive technical analysis of the engineering required to replicate the Raycast typewriter effect. It explores the foundational design tokens, the mathematical modeling of natural typing rhythms, the architectural patterns for React hooks, and the integration of emerging AI-assisted workflows using Gemini 3 Pro and Google Antigravity to accelerate the development of these high-fidelity components.
1.1 The Role of Micro-Interactions in Developer Tools
The prominence of the typewriter effect in developer-centric tools like Raycast is rooted in the psychology of the target audience. Developers and power users operate primarily via keyboard interfaces. The Command Line Interface (CLI) is their native tongue. By visualizing the UI through a typewriter animation, designers create a subconscious link between the GUI (Graphical User Interface) and the CLI, suggesting that the tool possesses the speed and power of the terminal with the discoverability of a modern app.
Analysis of the Raycast marketing materials and application design reveals that the typewriter effect is rarely used for generic marketing copy. Instead, it is employed to display syntax. It cycles through commands like /jira create-issue, /spotify play, or > toggle dark mode. This distinction is vital: the animation is a tutorial. It teaches the user the vocabulary of the application. Therefore, the implementation must be readable, perfectly paced, and visually distinct from the static UI elements surrounding it.
1.2 The Convergence of "Vibe Coding" and UI Engineering
The development landscape for creating such effects has shifted dramatically with the advent of AI-driven "vibe coding." As detailed in recent documentation regarding Gemini 3 Pro and Google Antigravity, developers are increasingly moving away from writing imperative animation loops from scratch and instead functioning as "architects" who direct AI agents to generate high-fidelity components.1 The ability to prompt an AI with "Generate a Raycast-style typewriter effect with smart backspacing and a blinking block cursor using Tailwind CSS" allows for rapid prototyping. However, the output of such prompts often requires deep technical refinement to meet production standards—specifically regarding performance optimization, accessibility compliance, and strict adherence to design tokens. This report bridges the gap between the AI-generated "slop" and the refined, engineering-grade code required for a flagship product.3
2. Anatomical Deconstruction of the Raycast Design System
To implement the "Raycast effect," one must first construct the environment in which it lives. The animation is symbiotic with its container. A typewriter effect placed on a white background with a generic sans-serif font fails to evoke the specific "hacker-chic" quality of the Raycast aesthetic. The foundation relies on a specific set of design tokens governing color, surface hierarchy, and typography.
2.1 The Dark Mode Architecture
Raycast, along with its contemporaries like Linear and Vercel, utilizes a refined dark mode palette that deliberately avoids pure black (#000000). Pure black on digital displays can cause "smearing" on OLED screens and creates excessive contrast that leads to eye strain (halation) when paired with bright white text. Instead, these systems employ a spectrum of rich, cold grays and desaturated blues to create depth.
Analysis of Raycast's theme data, specifically extracted from community theme repositories and extension configurations, reveals a sophisticated layering strategy. The background is rarely a static color but a composition of surfaces defined by luminance levels.
Table 1: Comparative Analysis of "Productivity Luxury" Dark Mode Palettes
Semantic Token
	Raycast Dark (Hex)
	Linear Dark (Hex)
	Vercel Dark (Hex)
	Contextual Usage
	background-base
	#0e1113
	#000000
	#000000
	The deepest layer of the application; the canvas.
	surface-primary
	#161618
	#1a1a1a
	#111111
	Cards, command bars, input fields, and elevated surfaces.
	surface-secondary
	#1c1c1f
	#222222
	#333333
	Hover states, active list items, or secondary groupings.
	text-primary
	#ededed
	#f7f8f8
	#ffffff
	Main headings and active input text; high readability.
	text-secondary
	#a1a1a1
	#8a8f98
	#888888
	Subtitles, metadata, and keyboard shortcuts.
	accent-primary
	#FF6363 (Red)
	#5E6AD2 (Indigo)
	#0070f3 (Blue)
	Brand highlights; often used for the typewriter cursor.
	border-subtle
	#ffffff1a
	#ffffff10
	#333333
	10-15% opacity white for defining component boundaries.
	Data synthesized from Raycast theme JSONs 5, Linear brand analysis 6, and Vercel design system documentation.8
The typewriter effect typically resides within a container styled with surface-primary (#161618 for Raycast). This ensures the text pops without vibrating against the background. The use of rgba or hsla values for borders (#ffffff1a) is a critical detail; it allows for the characteristic "glass" effect where background blurs (backdrop-filter) interact with the border opacity, creating a sense of physical depth.
2.2 Typography: The Ascendance of Geist
The visual identity of modern developer tools is inextricably linked to the Geist font family. Created by Vercel in collaboration with Basement Studio, Geist has become the de facto standard for this aesthetic, replacing Inter and system fonts in many high-end applications.9
For the typewriter effect, the choice of font subclass is paramount:
1. Geist Sans: Used for the UI shell. It features a geometric structure with deep ink traps, optimizing legibility at small sizes.
2. Geist Mono: This is the preferred font for the typewriter animation itself. Monospace fonts are technically superior for this specific animation because every character occupies the exact same width unit (1ch). This prevents the "jitter" or layout shifting that occurs when a variable-width font replaces a narrow letter (like 'i' or 'l') with a wide one (like 'w' or 'm'). Using a monospace font ensures the cursor moves in predictable, rhythmic increments, reinforcing the "terminal" metaphor.
CSS Implementation of the Font Stack:
To properly implement this, one must load the variable font files and define them as CSS variables for broad accessibility across the Shadow DOM and various component layers.


CSS




:root {
 --font-geist-sans: 'Geist Sans', system-ui, sans-serif;
 --font-geist-mono: 'Geist Mono', 'Menlo', 'Monaco', monospace;
}

.typewriter-container {
 font-family: var(--font-geist-mono);
 letter-spacing: -0.02em; /* Tight tracking for modern feel */
}

The snippets highlight that Raycast also supports user-customizable themes, meaning the implementation must be robust enough to handle dynamic font switching if integrated into an extension.5
2.3 The "Glowing" Text Effect
A signature visual flourish often paired with the typewriter effect in marketing contexts (though less so in the app utility) is a subtle glow surrounding the active text. This is not achieved through a standard text-shadow but rather a layered approach that simulates the phosphor persistence of old CRT monitors, modernized for 4K displays.
The technique involves stacking multiple shadows with varying blur radii to create a diffuse light field:
* Core Glow: 0 0 5px rgba(255, 99, 99, 0.5) – A tight, bright halo immediately surrounding the letter.
* Ambient Glow: 0 0 15px rgba(255, 99, 99, 0.3) – A wider, softer dispersion.
* Atmospheric Glow: 0 0 30px rgba(255, 99, 99, 0.1) – A faint background illumination.
Alternatively, modern CSS allows for gradient masking. Using background-clip: text with a linear-gradient allows the text itself to carry a gradient, transitioning from the brand color to white, simulating a "scanning" effect as the characters appear.11
3. The Mathematics of Natural Typing
A "naive" typewriter implementation uses a static interval (e.g., exactly 100ms per character). This creates a robotic, unnatural feel that users subconsciously identify as "fake." To achieve the premium feel of Raycast, the animation must emulate the physics of human typing.
3.1 Gaussian Distribution of Delay
Human typists do not maintain a constant metronome. There is latency involved in reaching for keys, cognitive pauses between words, and speed bursts during familiar sequences. To simulate this, the delay between characters should not be a static number but a variable derived from a randomized distribution.
The Variance Algorithm:
Instead of delay = 50, the optimal implementation uses a base speed with a jitter factor.




$$Delay = BaseSpeed + (Math.random() \times Variance)$$
* Base Speed: 40ms (Fast typing)
* Variance: 0 to 50ms (Random fluctuation)
This results in keystrokes occurring between 40ms and 90ms, creating a "rhythmic" texture to the animation. Further refinement involves adding distinct pauses for punctuation (commas, periods) which naturally signal a cognitive break in human sentence construction. A period might induce a 400ms pause, while a space might induce a 20ms pause.13
3.2 The Erasure Curve
Deleting text is typically faster than typing it. Humans hold down the backspace key, resulting in a rapid, constant-rate deletion, or they select-all and delete. The Raycast effect usually simulates the "hold backspace" behavior.
* Typing Speed: ~50-80ms per character (variable).
* Deleting Speed: ~20-30ms per character (constant or slightly accelerating).
This asymmetry is crucial for pacing. If the deletion is too slow, the user becomes bored waiting for the next string. If it is too fast, it feels jarring. The "accelerating" deletion model—where the first few characters delete slowly and then the speed ramps up—is a high-fidelity detail often found in these implementations.
3.3 Smart Backspacing
Perhaps the most significant logic differentiator in the Raycast effect is Smart Backspacing. A standard implementation deletes the entire string before typing the next. However, if the current string is "Search Jira" and the next string is "Search Linear," a human would not delete the word "Search." They would only backspace "Jira" and type "Linear."
The algorithm must calculate the Longest Common Prefix between the current string and the target string.
1. Let $S_1$ be the current displayed string.
2. Let $S_2$ be the next string in the queue.
3. Compute index $i$ where $S_1[i] \neq S_2[i]$.
4. The deletion phase stops when the string length equals $i$.
5. The typing phase begins immediately from index $i$.
This logic makes the animation feel intelligent and context-aware, significantly reducing the "time to value" for the user reading the text.
4. Implementation Strategy: The React State Machine
While CSS steps() functions can create a basic typewriter effect, they are fundamentally limited for the Raycast use case because they cannot easily handle dynamic arrays of strings, variable typing speeds, or the smart backspacing logic described above. A custom React hook, useTypewriter, is the requisite architectural pattern.
4.1 The Finite State Machine (FSM)
The hook effectively manages a finite state machine with four distinct states. Managing these states explicitly prevents race conditions where the typewriter might try to delete and type simultaneously.
1. TYPING: The cursor is moving forward, appending characters to the displayed string.
2. PAUSING: The full string is visible. The application waits for a "reading delay" (typically 1500ms - 3000ms).
3. DELETING: The cursor is moving backward, removing characters.
4. SWITCHING: The logic prepares the next string in the array and resets the index.
4.2 Handling the React Render Cycle and Strict Mode
A common pitfall in implementing this hook is the interaction between setTimeout and React 18's Strict Mode, which mounts, unmounts, and remounts components to stress-test side effects. A naive implementation that sets a timeout directly in the body of the component or without proper cleanup in useEffect will result in "double typing," where two timers run in parallel, causing the text to glitch or type twice as fast.
Best Practice Pattern:
The useEffect hook should manage the timeout, and crucially, it must return a clearTimeout function.


JavaScript




useEffect(() => {
 let timeout;
 
 if (phase === 'TYPING') {
   timeout = setTimeout(() => {
     // Typing logic
   }, typingSpeed);
 } else if (phase === 'DELETING') {
   timeout = setTimeout(() => {
     // Deleting logic
   }, deletingSpeed);
 }
 
 return () => clearTimeout(timeout);
}, [text, phase, index]); // Dependencies ensure fresh closures

This structure ensures that every time the state changes (a character is added), the previous timer is cleaned up, enforcing a strict serial execution of the typing events.14
4.3 Advanced Animation with Framer Motion
For the highest fidelity, developers within the Vercel/Linear ecosystem often bypass native setTimeout loops in favor of Framer Motion. Framer Motion abstracts the animation loop using requestAnimationFrame, which syncs the updates with the browser's refresh rate (usually 60hz or 120hz), resulting in significantly smoother character entry than setTimeout, which can drift or jitter if the main thread is blocked.
The Staggered Children Pattern:
Instead of updating a single string state, Framer Motion allows treating the sentence as a container of individual character components.


JavaScript




const sentenceVariants = {
 hidden: { opacity: 1 },
 visible: {
   opacity: 1,
   transition: {
     staggerChildren: 0.05, // The typing speed
   },
 },
};

const letterVariants = {
 hidden: { opacity: 0, y: 0 },
 visible: { opacity: 1, y: 0 },
};

In this model, the "typewriter" effect is actually a stagger animation. This approach is powerful because it allows for secondary effects—characters can "slide up" as they appear (y: 10 to y: 0), adding a subtle verticality that feels premium and modern, distinct from the raw terminal feel.13
5. The Cursor: Designing the Heartbeat
The blinking cursor is the visual anchor of the typewriter effect. In the Raycast design system, the cursor is not merely a line; it is a solid block (typically 1ch width) that mimics a terminal block cursor.
5.1 CSS Keyframes for Digital Blinking
A standard "fade" blink (using ease-in-out) feels soft and organic, which contradicts the mechanical nature of a typewriter. The Raycast cursor uses a step function to toggle visibility instantly.


CSS




@keyframes blink {
 0%, 100% { opacity: 1; }
 50% { opacity: 0; }
}

.cursor-block {
 display: inline-block;
 width: 0.6em;
 height: 1.2em;
 background-color: var(--accent-primary); /* Raycast Red #FF6363 */
 animation: blink 1s step-end infinite;
 vertical-align: middle;
}

The step-end timing function is the critical technical detail here. It creates the harsh, immediate on/off state characteristic of command-line interfaces.16
5.2 Conditional Animation Logic
A nuance found in high-end code editors (VS Code, Sublime Text) and replicated in the Raycast effect is that the cursor suspends blinking while typing occurs. If the cursor blinks during the rapid appearance of text, it creates visual noise and can make the cursor appear to disappear entirely if the blink phase aligns poorly with the typing speed.
Implementation Detail:
The React component should apply a conditional class to the cursor.
* State: isTyping (True during 'TYPING' or 'DELETING' phases).
* Logic: className={isTyping? 'cursor-solid' : 'cursor-blinking'}.
* CSS: .cursor-solid sets opacity: 1 and removes the animation. .cursor-blinking applies the keyframe animation.
This micro-interaction ensures the cursor is always visible leading the text generation, only resuming its idle breathing pattern when the user (or system) pauses to think.
6. Layout Stability and Performance Metrics
A major engineering challenge with dynamic text is Cumulative Layout Shift (CLS). As the typewriter adds characters, the text container expands. If this container is centered or part of a grid, the expansion can push surrounding elements (buttons, images) to the side, causing the entire UI to jitter. This is visually fatiguing and negatively impacts Core Web Vitals.
6.1 The "Ghost" Element Solution
To prevent CLS, the container must reserve the space for the longest possible string in the array before the animation begins.
* Technique: Render the longest string in the array inside a <span> with visibility: hidden (or opacity: 0). This "ghost" element dictates the width and height of the parent container.
* Overlay: Position the actual typewriter animation absolutely over this ghost element (position: absolute; top: 0; left: 0;).
* Result: The container size remains static (locked to the maximum width), and the text types freely within this reserved space without disturbing the document flow.
6.2 CSS ch Units
When defining widths for monospace typewriter effects, the ch unit is invaluable. 1ch is equivalent to the width of the "0" character in the current font. For monospace fonts, 20ch effectively reserves space for exactly 20 characters. This allows for precise, CSS-only reservation strategies if the maximum character count is known ahead of time.
7. AI-Assisted Development: The Gemini 3 Workflow
In the current development ecosystem (2025-2026), manual implementation of these hooks is increasingly augmented by AI tools. The research highlights the efficacy of models like Gemini 3 Pro and Flash in generating these components via "Vibe Coding".1
7.1 "KingMode" and Persona-Based Prompting
To generate a component that meets the strict "Raycast" criteria (rather than a generic typewriter effect), developers employ "KingMode" or "Senior Architect" personas. Standard AI outputs often default to simpler, less performant code (e.g., missing cleanup functions or smart backspacing).
Optimal Prompt Structure:
"Act as a Senior Design Systems Engineer. Create a React 'Typewriter' component using Tailwind CSS and Framer Motion.
Constraints:
1. Use Geist Mono.
2. Implement 'Smart Backspacing' (calculate common prefix).
3. Use the step-end blinking cursor logic.
4. Ensure 0 layout shift using the 'ghost element' technique.
5. Use the Raycast Dark Mode palette (#161618 background, #FF6363 cursor)."
This workflow shifts the engineering effort from writing boilerplate to refining the "physics" of the animation—tweaking the delay variance and pause durations to hit the "uncanny valley" of human-like typing.4
7.2 Google Antigravity Integration
Tools like Google Antigravity allow for an agentic loop where the developer defines the "vibe" (e.g., "Make it feel like a terminal in a sci-fi movie"), and the agent iterates on the CSS text-shadow and timing functions autonomously, previewing the results in real-time. This allows for rapid exploration of "Flash UI" concepts—where physical metaphors like "phosphor decay" or "obsidian reflection" are applied to standard UI elements.2
8. Contextual Deployment: The Bento Grid
The Raycast typewriter effect does not exist in isolation. It is the dynamic anchor of the Bento Grid—a layout trend inspired by Apple promotional materials and Japanese bento boxes. A Bento Grid divides the UI into modular, rectangular tiles of varying sizes.20
8.1 The "Live" Tile
In a static grid of feature cards, the eye is evolutionarily programmed to detect motion. By placing the typewriter effect inside a specific tile (usually the "Command Palette" or "Search" tile), designers control the user's visual hierarchy. The moving text draws the eye first, establishing the core value proposition ("Search anything..."), while the surrounding static tiles provide secondary context.
Table 2: Design Token Integration in Bento Grids
Component
	Property
	Value (Raycast Style)
	Reason
	Grid Gap
	gap
	16px or 1rem
	consistent spacing creates modularity.
	Tile Radius
	border-radius
	12px to 16px
	Smooths corners, matching modern OS windows.
	Glass Effect
	backdrop-filter
	blur(12px)
	Allows background colors to bleed through, creating depth.
	Typewriter Font
	font-family
	Geist Mono
	Distinguishes the "active" tile from "static" tiles using Sans.
	8.2 Responsive Considerations
Bento grids are inherently responsive (often using CSS Grid minmax functions). The typewriter component must be robust enough to handle resizing. Using clamp() for font sizing ensures that the text inside the typewriter tile scales fluidly between mobile and desktop views without breaking the reserved layout space.
9. Accessibility and Reduced Motion
A truly production-ready implementation must account for users who may be distracted or disoriented by rapid animation.
9.1 The prefers-reduced-motion Media Query
The hook should listen for the OS-level prefers-reduced-motion setting.
* Logic: If matches: true, the typewriter effect should be disabled. The component should render the full, final string immediately. This respects the user's need for stability.
9.2 Screen Reader Optimization
A raw typewriter effect is catastrophic for screen readers (VoiceOver, NVDA). As each character is added to the DOM, the screen reader might announce "G... Gi... Git...".
Solution:
1. Hide the animating text from the accessibility tree using aria-hidden="true".
2. Render the full current sentence in a visually hidden span (using .sr-only class) that is exposed to the screen reader.
3. Use aria-live="polite" on the container so updates are announced only when the full sentence changes, rather than on every keystroke.
10. Conclusion
Implementing the Raycast typewriter effect is a microcosm of modern frontend engineering. It requires traversing the stack from the low-level physics of the animation (Gaussian delay distributions) to the high-level architecture of React state management, all while adhering to a strict, aesthetically opinionated design system.
The difference between a generic typewriter animation and the "Raycast" effect lies in the details: the use of Geist Mono, the semantic dark mode palette (#161618 and #FF6363), the smart backspacing logic, and the layout stability measures. By leveraging AI-assisted coding workflows like Gemini 3 Pro to generate the boilerplate and refining the interaction with Framer Motion, developers can achieve this level of fidelity efficiently. The result is a UI component that does more than display text—it breathes life into the application, transforming a static interface into a dynamic narrative of utility and speed.
11. Citations & Sources
* Design Systems & Colors: 5
* Typography (Geist): 9
* Typewriter Implementation (React/CSS): 13
* AI Coding & Workflows: 1
* Bento Grid & Context: 20
* Glow & Visual Effects: 11
Works cited
1. Gemini 3 for developers: New reasoning, agentic capabilities - Google Blog, accessed on January 4, 2026, https://blog.google/technology/developers/gemini-3-developers/
2. Introducing Google Antigravity, a New Era in AI-Assisted Software Development, accessed on January 4, 2026, https://antigravity.google/blog/introducing-google-antigravity
3. PM here using Cursor & Antigravity for vibe-coding MVPs — how do you prompt for a clean dev handoff? : r/vibecoding - Reddit, accessed on January 4, 2026, https://www.reddit.com/r/vibecoding/comments/1ps05co/pm_here_using_cursor_antigravity_for_vibecoding/
4. Gemini 3 PRO ULTRA MODE (KingMode Prompt): This SIMPLE TRICK MAKES Gemini 3 PRO - A BEAST!, accessed on January 4, 2026, https://lilys.ai/en/notes/gemini-3-pro-20260102/gemini-3-pro-simple-trick-beast
5. themes/Raycast.json 4.0.1 - PowerShell Gallery, accessed on January 4, 2026, https://www.powershellgallery.com/packages/Universal/4.0.1/Content/themes%5CRaycast.json
6. Linear Brand Color Palette: Hex, RGB, CMYK and UIs - Mobbin, accessed on January 4, 2026, https://mobbin.com/colors/brand/linear
7. colors.json - atomic-framework-project/design-system · GitHub, accessed on January 4, 2026, https://github.com/atomic-framework-project/design-system/blob/master/defaults/colors/colors.json
8. Colors - Vercel, accessed on January 4, 2026, https://vercel.com/geist/colors
9. How to use Vercel's Geist Font in Next.js? - Peerlist, accessed on January 4, 2026, https://peerlist.io/blog/engineering/how-to-use-vercel-geist-font-in-nextjs
10. geist - NPM, accessed on January 4, 2026, https://www.npmjs.com/package/geist?activeTab=readme
11. CSS Tip - Gradient Text Effect #shorts - YouTube, accessed on January 4, 2026, https://www.youtube.com/shorts/nGbFYuyAzZM
12. CSS Gradient Text, accessed on January 4, 2026, https://cssgradient.io/blog/css-gradient-text/
13. Typewriter: Realistic typing animations in React - Motion, accessed on January 4, 2026, https://motion.dev/docs/react-typewriter
14. Creating a typewriter effect in React (using JS) - Stack Overflow, accessed on January 4, 2026, https://stackoverflow.com/questions/77869504/creating-a-typewriter-effect-in-react-using-js
15. Typewriter effect in React - javascript - Stack Overflow, accessed on January 4, 2026, https://stackoverflow.com/questions/59786811/typewriter-effect-in-react
16. How to Create a CSS Typewriter Effect for Your Website - SitePoint, accessed on January 4, 2026, https://www.sitepoint.com/css-typewriter-effect/
17. Typewriter Effect - CSS-Tricks, accessed on January 4, 2026, https://css-tricks.com/snippets/css/typewriter-effect/
18. I made a free gallery of 31 actually-good UI design prompts, each a different style on the exact same content : r/vibecoding - Reddit, accessed on January 4, 2026, https://www.reddit.com/r/vibecoding/comments/1pcy8bi/i_made_a_free_gallery_of_31_actuallygood_ui/
19. This SECRET Gemini 3 Flash Prompt Makes AI Design 100x Better - YouTube, accessed on January 4, 2026, https://www.youtube.com/watch?v=SQ4J58orXTk
20. Best Bento Grid Design Examples [2025] - Mockuuups Studio, accessed on January 4, 2026, https://mockuuups.studio/blog/post/best-bento-grid-design-examples/
21. Dark theme - Material Design, accessed on January 4, 2026, https://m2.material.io/design/color/dark-theme.html
22. light-dark() - CSS - MDN Web Docs - Mozilla, accessed on January 4, 2026, https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/color_value/light-dark
23. Geist - Vercel, accessed on January 4, 2026, https://vercel.com/geist/introduction
24. How to Create Typewriter Effect in ReactJS? - GeeksforGeeks, accessed on January 4, 2026, https://www.geeksforgeeks.org/reactjs/how-to-create-typewriter-effect-in-reactjs/
25. Embracing the Bento Grid: A Modern Approach to UI Layouts | by Jaco Verdini - Prototypr, accessed on January 4, 2026, https://blog.prototypr.io/embracing-the-bento-grid-a-modern-approach-to-ui-layouts-4a15f618e751
26. 47 Best Glowing Effects in CSS [2025] | LambdaTest, accessed on January 4, 2026, https://www.lambdatest.com/blog/glowing-effects-in-css/
27. Building a dark-mode theme with CSS variables, accessed on January 4, 2026, https://pedromarquez.dev/blog/2022/7/dark-mode-css